import { writeCreate } from './create'
import { writeDelete } from './delete'
import { writeEditorInterfaceChange } from './editor_interface'
import { writeModify } from './modify'
import buildRunner from './runners/index'
import Source from './source'
import { indexByContentType, indexById } from './utils'

export interface IArgs {
  /** A contentful export file, or Contentful Space ID */
  from: string,
  /** A contentful export file, space ID, or environment within the "from" space */
  to: string,
  /** (optional) Write all the migrations in a single file */
  oneFile?: boolean,
  // (optional) Directory where class models are stored. We can use those to diff against your contentful environment
  modelsDirectory?: string,
  /** The output directory (or file if '--oneFile' was specified) */
  out: string,
  /**
   * A Contentful management token to download content types from a space.
   * Not required if both `from` and `to` are files.
   */
  managementToken?: string
  /** Generate a migration only for these content types. */
  contentTypes: string[]
}

export default async function Run(args: IArgs) {
  const [from, to] = await Source.loadSources(args)

  const fromTypes = indexById(from.contentTypes)
  const fromEditorInterfaces = indexByContentType(from.editorInterfaces)
  const toTypes = indexById(to.contentTypes)
  const toEditorInterfaces = indexByContentType(to.editorInterfaces)

  const runner = buildRunner(args, ...buildHeaderAndFooter(args))

  await runner.init()

  await Promise.all([
    runner.run(Object.keys(toTypes), async (id, chunkWriter, context) => {
      if (fromTypes[id]) {
        await writeModify(fromTypes[id], toTypes[id], chunkWriter, context)
      } else {
        await writeCreate(toTypes[id], chunkWriter, context)
      }
      return writeEditorInterfaceChange(fromEditorInterfaces[id], toEditorInterfaces[id], chunkWriter, context)
    }),
    Promise.all(
      runner.run(Object.keys(fromTypes), (id, chunkWriter, context) => {
        if (toTypes[id]) {
          // handled above in 'writeModify'
          return Promise.resolve()
        }

        return writeDelete(id, chunkWriter, context)
      }),
    ),
  ])

  return await runner.close()
}

function buildHeaderAndFooter(args: IArgs): [string, string] {
  const HEADER = `// Generated by contentful-schema-diff
// from ${args.from}
// to   ${args.to}
module.exports = (migration) => {
`

  const FOOTER = `
}
`
  return [HEADER, FOOTER]
}